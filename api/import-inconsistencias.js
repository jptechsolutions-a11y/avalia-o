import { createClient } from '@supabase/supabase-js';

// Carrega as variáveis de ambiente
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_KEY;

const DATA_TABLE = 'inconsistencias_data';
const META_TABLE = 'inconsistencias_meta';

// Helper para gerar um ID único (necessário se a tabela não tiver auto-incremento ou UUID default)
// No entanto, o SQL fornecido usa 'BIGINT GENERATED BY DEFAULT AS IDENTITY', então não precisamos enviar 'id'.

export default async (req, res) => {
    // 1. Validação do Método
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Método não permitido' });
    }

    // 2. Validação das Variáveis de Ambiente
    if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY) {
        console.error("[import-inconsistencias] Variáveis de ambiente Supabase não configuradas.");
        return res.status(500).json({ 
            error: 'Falha de Configuração do Servidor', 
            details: 'Variáveis de ambiente do Supabase não configuradas' 
        });
    }

    const supabaseAdmin = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

    try {
        // 3. Validação do Usuário (Admin)
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            console.error("[import-inconsistencias] Token JWT do usuário não encontrado no header.");
            return res.status(401).json({ error: 'Não autorizado. Token JWT necessário.' });
        }
        const token = authHeader.split(' ')[1];
        
        const { data: { user }, error: userError } = await supabaseAdmin.auth.getUser(token);
        if (userError || !user) {
            console.error("[import-inconsistencias] Falha na autenticação do token:", userError?.message || 'Token inválido');
            return res.status(401).json({ error: 'Token inválido ou expirado.', details: userError?.message });
        }

        const { data: profile, error: profileError } = await supabaseAdmin
            .from('usuarios')
            .select('role')
            .eq('auth_user_id', user.id)
            .single();

        if (profileError || profile?.role !== 'admin') {
            console.error(`[import-inconsistencias] Usuário ${user.email || user.id} não é admin. Role: ${profile?.role}`);
            return res.status(403).json({ error: 'Acesso negado. Requer permissão de administrador.' });
        }
        
        // 4. Recebimento e Validação dos Dados
        let newData = req.body;
        if (!Array.isArray(newData) || newData.length === 0) {
            return res.status(400).json({ error: 'Corpo da requisição deve ser um array não-vazio de dados.' });
        }
        
        // Mapeia as chaves para minúsculas (padrão Supabase)
        // E remove o ID, pois a tabela irá gerá-lo.
        const preparedData = newData.map(item => {
            const newItem = {};
            for (const key in item) {
                if (Object.prototype.hasOwnProperty.call(item, key)) {
                    newItem[key.toLowerCase()] = item[key];
                }
            }
            delete newItem.id; // Remove qualquer 'id' vindo do frontend
            return newItem;
        });

        console.log(`[import-inconsistencias] Recebidos ${preparedData.length} registros do admin ${user.email}`);
        
        // --- INÍCIO DO PROCESSO DE IMPORTAÇÃO (Delete + Insert) ---
        
        // Etapa 1: Limpeza da Base Antiga
        const { error: deleteError } = await supabaseAdmin
            .from(DATA_TABLE)
            .delete()
            .neq('id', 0); // Condição para deletar tudo

        if (deleteError) {
             console.warn(`[import-inconsistencias] Aviso: Falha ao limpar base antiga.`, deleteError.message);
             throw new Error(`Falha ao limpar dados antigos: ${deleteError.message}`);
        }

        // Etapa 2: Inserção dos novos dados em lotes (batch)
        const BATCH_SIZE = 500;
        for (let i = 0; i < preparedData.length; i += BATCH_SIZE) {
            const batch = preparedData.slice(i, i + BATCH_SIZE);
            console.log(`[import-inconsistencias] Inserindo lote ${i / BATCH_SIZE + 1}...`);
            const { error: insertError } = await supabaseAdmin
                .from(DATA_TABLE)
                .insert(batch); 

            if (insertError) {
                console.error('[import-inconsistencias] Erro na INSERÇÃO do lote:', insertError);
                throw new Error(`Falha ao importar novos dados (lote ${i / BATCH_SIZE + 1}): ${insertError.message}`); 
            }
        }
        
        // Etapa 3: Atualizar os metadados (data da última atualização)
        const { error: metaError } = await supabaseAdmin
            .from(META_TABLE)
            .upsert({ id: 1, lastupdatedat: new Date().toISOString() }, { onConflict: 'id' }); 

        if (metaError) {
            console.warn(`[import-inconsistencias] Falha ao atualizar metadados: ${metaError.message}`);
        }

        // 5. Sucesso
        res.status(200).json({ 
            message: `Importação concluída! ${preparedData.length} registros processados.` 
        });

    } catch (error) {
        console.error('[import-inconsistencias] Erro fatal na API:', error.message);
        res.status(500).json({ 
            error: 'Falha interna do servidor', 
            details: error.message 
        });
    }
};
